## 1：事务

​    何为事务？一言蔽之，事务是逻辑上的一组操作，要么都执行，要么都不执行。数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：**要么全部执行成功,要么全部不执行** 。

### 1.1 何为 ACID 特性

1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性**（`Durability`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 1.2 mysql如何实现相关原理

​    我们这里以 MySQL 的 InnoDB 引擎为例来简单说一下。MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

### 1.3 并发事务带来哪些问题

​    在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
- **不可重复读（Unrepea/table read）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

### 1.4 事务的隔离级别有哪些

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

## 2：锁的相关概念

### 2.1 行锁

​    InnoDB的行锁（也称为临键锁） Next-Key Locks，**「是MySQL对外暴露的锁的基本单位，它会智能选择记录锁或间隙锁，锁住一行或多行或一个间隙」**。而记录锁又分为共享锁和排他锁，间隙锁的概念下面有一个插入意向锁。这些锁的关系大概是这样：

![image-20211225164454863](E:\study\images\image-20211225164454863.png)

#### 2.1.1 记录锁

​    所谓记录锁 Record Locks，就是锁住确定的一行行记录。它分为共享锁和排它锁。分别对应不同的SQL写法。

**共享锁(Shared Locks)：**

​    允许事务读一行数据。

```sql
SELECT ... LOCK IN SHARE MODE
```

​    之所以说“可能”触发，是因为它查到了数据库有确定的记录才会锁住这些记录，否则会变成间隙锁。这个其实很好理解，找到了数据，才锁它。如果没找到数据，就锁这个间隙。

**排他锁：(Exclusive locks )**

允许事务删除或更新一行数据。

```sql
SELECT ... FOR UPDATE
```

#### 2.1.2 间隙锁

​    锁住一个间隙。上文我们提到过，InnoDB默认的隔离级别是RR，但是通过间隙锁来一定程度上的解决了幻读的问题

​    上面两种SQL，如果没有查找到确定的记录，就会根据条件去锁住一个间隙。间隙锁是根据已有数据的一个左开右闭的区间。

```sql
-- 锁住(0, 5]
SELECT * FROM demo where id = 3;

-- 锁住(10, 15]
SELECT * FROM demo where id = 11;
```

​    间隙锁其实是“共享”的。也就是说，多个事务可以获取同一个区间的间隙锁。





## 3: 事务

### 3.1 分类

事务可以分为以下几类：

- 扁平事务
- 带有保存点的扁平事务
- 链事务
- 嵌套事务
- 分布式事务

**扁平事务**

​    所有操作都处于同一层级，其间的操作是原子的，要么都执行，要么都回滚。

**带有保存点的扁平事务：**

​    允许事务再执行过程中回滚到同一事务中较早的一个状态。当出现错误时不会导致所有的操作都无效。

**链事务：**

​    带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为保存点是易失去的，而非持久的。意思是当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。**思想：**在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式的传给下一个要开始的事务。

**嵌套事务：**

​    由一个顶层事务控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，其控制着每一个局部的变换。



### 3.2 实现

​    事务的隔离性是通过锁来实现。原子性，一致性，持久性通过数据库的redo log和undo log来完成。redo log称为重做日志，用来保证事务的原子性和持久性，undo log 用来保证事务的一致性。

#### 3.2.1 undo log

​     这个文件主要用来帮助事务回滚

​    undo是逻辑日志，只是将数据库逻辑恢复到原来的样子，所有的修改都被逻辑的取消了。并不是将一个页回滚到事务开始的样子。比如用户执行了10W条的INSERT语句，这个事务会导致分配了一个新的段，即表空间会增大。在用户执行ROLLBACK之后，会将插入的事务进行回滚，但是表空间大小不会收缩。

  undo另一个作用是MVCC，当用户读取一行数据的时候，若该记录被其它事务占用，当前事务可以通过undo读取之前行版本信息，以此来实现非锁定读取。

  分为 insert undo log 和 update undo log 。第一个是值在insert操作中产生的undo log。因为在insert操作中，只对事务本身可见，其它事务不可见，所以提交后直接删除。

#### 3.2.2 redo log

重做日志用来实现事务的持久性，一是内存中的重做日志缓冲，二是重做日志文件，这个是持久的。即当事务提交时，必须将该事务的所有日志写入到重做日志文件中进行持久化，待事务的commit操作完成才算完成。

#### 3.2.3 purge

​    purge 用于最终完成delete和update操作。



## 4：MVCC

​    多版本并发控制，主要是为了提高数据库的并发性能。主要是读写请求发生冲突时不用加锁。这个读是快照读，而不是当前读。

**当前读**
    它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作。

**当前读**
    它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作。

**MVCC解决并发哪些问题？**
    mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联。读操作只读取该事务开始前的数据库快照。

**解决问题如下：**

​    并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。

​    解决脏读、幻读、不可重复读等事务隔离问题，但不能解决上面的写-写 更新丢失问题。

**因此有了下面提高并发性能的组合拳：**

​    MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突

​    MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突

**MVCC的实现原理**
    它的实现原理主要是版本链，undo日志 ，Read View 来实现的

**undo日志**
Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log里。

当事务进行回滚时可以通过undo log 里的日志进行数据还原。

**Undo log 的用途**

保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。

用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。

**undo log主要分为两种：**

insert undo log

代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃

update undo log（主要）

事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；

所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除