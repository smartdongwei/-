---
title: java内存模型
tags: [java基础]
date: 2020-10-10 10:00:00
---



##java 内存模型  JMM

###1: java内存模型的基本概念   

​      当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。随着CPU性能的不断提高，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。



​    **Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。**

​    Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

![image-20200412165224038](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20200412165224038.png)

​    JMM就作用于工作内存和主存之间数据同步过程，他规定了如何做数据同步以及什么时候做数据同步。

==主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分 ？？？？？==

   **在Java中提供了一系列和并发处理相关的关键字，比如`volatile`、`synchronized`、`final`、`concurren`包等，来解决原子性、有序性和一致性的问题**

volatile



### 2：可见性

​    java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。

![](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20200412165145016.png)

  

![image-20200412232120401](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20200412232120401.png)