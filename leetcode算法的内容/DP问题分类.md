---
title: DP问题的相关代码
tags: [算法]
date: 2021-05-01 11:31:30
---

# DP问题的相关代码

​    动态规划的特点：重叠子问题 ，状态转移方程，最优子结构

​    解题套路： 明确状态，明确选择，明确dp函数的定义，明确base case



## 1：线性DP

​	线性动态规划，是较常见的一类动态规划问题，其是在线性结构上进行状态转移，这类问题不像背包问题、区间DP等有固定的模板。线性动态规划的目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值。

### 1.1 最经典单串[最长上升子序列)：

​	给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 
```

#### 1.1.1 使用动态规划的方法获取

 	动态规划的一个特点就是当前解可以由上一个阶段的解推出， 由此，把我们要求的问题简化成一个更小的子问题。子问题具有相同的求解方式，只不过是规模小了而已。最长上升子序列就符合这一特性。我们要求n个数的最长上升子序列，可以求前n-1个数的最长上升子序列，再跟第n个数进行判断。求前n-1个数的最长上升子序列，可以通过求前n-2个数的最长上升子序列……直到求前1个数的最长上升子序列，此时LIS当然为1。

​	让我们举个例子：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。

- 　　前1个数 d(1)=1 子序列为2；

- 　　前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7

- 　　前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1

- 　　前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5

- 　　前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6

- 　　前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4

- 　　前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3

- 　　前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8

- 　　前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9

- 　　d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的LIS为d(9)=5

​    **每次都向前找比它小的数和比它大的数的位置，将第一个比它大的替换掉，这样操作虽然LIS序列的具体数字可能会变，但是很明显LIS长度还是不变的。**

**复杂度分析**

- 时间复杂度：O(n^2)，其中 n为数组nums*的长度

- 空间复杂度：O(n)，需要额外使用长度为 nn 的 dp 数组。


```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
}
```

#### 1.1.2  贪心 + 二分查找

​	如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。

​	设当前已求出的最长上升子序列的长度为len，从前往后遍历数组nums，在遍历到 nums[i] 时：

- 如果 nums[i] >d[len] ，则直接加入到 dd 数组末尾，并更新 len = len + 1；

- 否则，在 dd 数组中二分查找，找到第一个比 nums[i]小的数 d[k] ，并更新 d[k + 1] = nums[i]。

  **以输入序列 [0, 8, 4, 12, 2][0,8,4,12,2] 为例：**

- 第一步插入 0，d=[0]；

- 第二步插入 8，d=[0,8]；

- 第三步插入 4，d=[0,4]；

- 第四步插入 12，d=[0,4,12]；

- 第五步插入 2，d=[0,2,12]。

- 最终得到最大递增子序列长度为 33。


```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = 1, n = nums.length;
        if (n == 0) {
            return 0;
        }
        int[] d = new int[n + 1];
        d[len] = nums[0];
        for (int i = 1; i < n; ++i) {
            if (nums[i] > d[len]) {
                d[++len] = nums[i];
            } else {
                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (d[mid] < nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
}
```



### 1.2最长公共子序列

​    给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

​    例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。



### 1.3 最长公共子串

  给定两个字符串str1和str2,输出两个字符串的最长公共子串 题目保证str1和str2的最长公共子串存在且唯一。

  示例1

>    1AB2345CD,  12345EF
>
>    2345 

相关的代码如下图：

```java
/**
 * 动态规划解最长公共字串
 * @param str1
 * @param str2
 * @return
 */
public static String LCS(String str1,String str2){
    // 记录最长公共子串的长度
    int maxLength = 0;
    // 记录最长公共子串最后一个和元素在字符串str1中的位置
    int maxLastIndex = 0;
    int[][] dp = new int[str1.length() +1][str2.length()+1];
    for(int i=0;i<str1.length();i++){
        for(int j=0;j<str2.length();j++){
            // 递推公式 两个字符相等的情况
            if(str1.charAt(i) == str2.charAt(j)){
                dp[i+1][j+1] = dp[i][j]+1;
                // 如果遇到了更长的子串，要更新记录最长子串的长度
                // 以及最长子串最后一个元素的位置
                if(dp[i+1][j+1] > maxLength){
                    maxLength = dp[i+1][j+1];
                    maxLastIndex = i;
                }
            }else{
                // 递推公式 两个字符不相等的情况
                dp[i+1][j+1] = 0;
            }
        }
    }
    // 对原字符串进行截取
    return str1.substring(maxLastIndex - maxLength +1,maxLastIndex+1);
}
```



### 1.4动态规划解单词拆分

​    给定一个非空字符串s和一个包含非空单词的列表wordDict，判定s是否可以被空格拆分为一个或多个在字典中出现的单词。

```
public static boolean wordBreak(String s, List<String> dict){
    boolean[] dp = new boolean[s.length() +1];
    // 边界条件
    dp[0] = true;
    for(int i = 1;i<s.length();i++){
        for(int j=0;j<i;j++){
            dp[i] = dp[j] && dict.contains(s.substring(j,i));
            if(dp[i]){
                break;
            }
        }
    }
    return dp[s.length()];
}
```



### 1.5 动态规划解分割回文串

​    给你一个由小写字母组成的字符串s，和一个整数k。

>  请你按下面的要求分割字符串： 
>
> 首
>
> 
>
> 
>
> 先，你可以将s中的部分字符修改为其他的小写英文字母。 
>
> 接着，你需要把s分割成k个非空且不相交的子串，并且每个子串都是回文串。
>
>  请返回以这种方式分割字符串所需修改的最少字符数。