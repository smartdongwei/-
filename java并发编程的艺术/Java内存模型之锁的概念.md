---
title: 锁的相关信息
tags: [java并发编程]
date: 2021-03-12 20:22:10
---

## 1.5 锁的四种状态以及锁升级降级

### 1.5.3锁的四种状态

​    锁的状态总共有四种，级别由低到高依次为：**无锁、偏向锁、轻量级锁、重量级锁**。**并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级，也就是说只能进行锁升级（从低级别到高级别），不能锁降级（高级别到低级别）**，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

​    锁状态的改变是根据竞争激烈程度进行的，在几乎无竞争的条件下，会使用偏向锁，在轻度竞争的条件下，会由偏向锁升级为轻量级锁， 在重度竞争的情况下，会升级到重量级锁。

![在这里插入图片描述](E:\study\images\20200603161323889.png)



### 1.5.4 无锁

- 无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。
- 无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。
- 如果没有冲突就修改成功并退出，否则就会继续循环尝试。
- 如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。

### 1.5.5 偏向锁

- 为了降低获取锁的代价，才引入的偏向锁。

- 初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“**偏向于第一个获得它的线程**”的锁。

- 执行完同步代码块后，线程并不会主动释放偏向锁。

- 当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（**持有锁的线程ID也在对象头里**），如果是则正常往下执行。

- 由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高；

- **偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能**。

- 当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。

- 在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。

- 轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。

- 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，**线程是不会主动释放偏向锁的。**

- 关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。