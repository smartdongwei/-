# Eureka源码解析

## 1：客户端启动时如何注册到服务端

### 1.1 总结

​    Eureka客户端在启动时，首先会创建一个心跳的定时任务，定时向服务端发送心跳信息，服务端会对客户端心跳做出响应，如果响应状态码为404时，表示服务端没有该客户端的服务信息，那么客户端则会向服务端发送注册请求，注册信息包括服务名、ip、端口、唯一实例ID等信息，心跳间隔时间默认是30秒。

### 1.2 源码分析

​    Eureka客户端在启动后，会创建一些定时任务，其中就有一个任务heartbeatExecutor就是就是处理心跳的线程池，部分源码（源码位置：com.netflix.discovery.DiscoveryClient）如下：

## 2：服务端如何保存客户端服务信息

### 2.1 总结

​    客户端通过Jersey框架（亚马逊的一个http框架）将服务实例信息发送到服务端，服务端将客户端信息放在一个ConcurrentHashMap对象中。



## 3：客户端如何拉取服务端已保存的服务信息

### 3.1 总结

​    客户端拉取服务端服务信息是通过一个定时任务定时拉取的，每次拉取后刷新本地已保存的信息，需要使用时直接从本地直接获取，默认为30秒时间。

​    在**服务消费者**启动时，会检测`eureka.client.fetch-registry=true`参数的值，如果为true，则会从**Eureka Server**服务的列表只读备份，然后缓存在本地。并且`每隔30秒`会重新获取并更新数据。

```
eureka:
  client:
    registry-fetch-interval-seconds: 30
```





## 4：如何构建高可用的Eureka集群

### 4.1 总结

首先，搭建一个高可用的Eureka集群，只需要在每个注册中心（服务端）通过配置：

```
eureka.client.service-url.defaultZone
```

指定其他服务端的地址，多个使用逗号隔开，如：

```
eureka.client.service-url.defaultZone=http://localhost:10000/eureka/,http://localhost:10001/eureka/,http://localhost:10002/eureka
```

​     那么问题来了，一旦 其中一个eureka收到一个客户端注册实例时，既然eureka注册中心将注册在自己的实例同步到其他注册中心中的方式和客户端注册的方式相同，那么在接收的eureka注册中心一端，会不会再同步回给注册中心（或者其他注册中心），从而导致死循环。

​    注册中心收到注册信息后会判断是否是其他注册中心同步的信息还是客户端注册的信息，如果是客户端注册的信息，那么他将会将该客户端信息同步到其他注册中心去；否则收到信息后不作任何操作。通过此机制避免集群中信息同步的死循环。

## 5：心跳和服务剔除机制是什么

### 5.1 总结

**心跳机制：**

​     客户端启动后，就会启动一个定时任务，定时向服务端发送心跳数据，告知服务端自己还活着，默认的心跳时间间隔是30秒。
**服务剔除机制：**

​    如果开启了自我保护机制，那么所有的服务，包括长时间没有收到心跳的服务（即已过期的服务）都不会被剔除；如果未开启自我保护机制，那么将判断最后一分钟收到的心跳数与一分钟收到心跳数临界值（计算方法参考5.1节）比较，如果前者大于后者，且后者大于0的话，则启用服务剔除机制；
一旦服务剔除机制开启，则Eureka服务端并不会直接剔除所有已过期的服务，而是通过随机数的方式进行剔除，避免自我保护开启之前将所有的服务（包括正常的服务）给剔除。

